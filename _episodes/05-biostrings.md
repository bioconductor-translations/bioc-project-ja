---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 05-biostrings.md in _episodes_rmd/
source: Rmd
title: "Biostrings"
teaching: XX
exercises: XX
questions:
- "What is the recommended way to represent biological sequences in Bioconductor?"
- "What packagaes and methods does Bioconductor provide to efficiently process biological sequences?"
objectives:
- "Explain how biological sequences are represented in the Bioconductor project."
- "Identify Bioconductor packages and methods available to process biological sequences."
- "Create objects and process them using methods from differerent packages in a single workflow."
keypoints:
- "The `Biostrings` package defines classes to represent sequences of nucleotides and amino acids."
- "The `Biostrings` package also defines methods to efficiently process biological sequences."
---





# Install packages

Before we can proceed into the following sections, we install some Bioconductor packages that we will need.


~~~
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Biostrings")
~~~
{: .language-r}


# The Biostrings package and classes

## Why do we need classes for biological sequences?

Biological sequences are arguably some of the simplest biological entities to represent computationally.
Examples include nucleic acid sequences (e.g., DNA, RNA) and protein sequences composed of amino acids.

That is because alphabets have been designed and agreed upon to represent individual monomers using character symbols.

For instance, using the alphabet for amino acids, the protein sequence for the [Actin, alpha skeletal muscle protein sequence](https://www.uniprot.org/uniprot/P68133#sequences) is represented as follows.


~~~
[1] "MCDEDETTALVCDNGSGLVKAGFAGDDAPRAVFPSIVGRPRHQGVMVGMGQKDSYVGDEAQSKRGILTLKYPIEHGIITNWDDMEKIWHHTFYNELRVAPEEHPTLLTEAPLNPKANREKMTQIMFETFNVPAMYVAIQAVLSLYASGRTTGIVLDSGDGVTHNVPIYEGYALPHAIMRLDLAGRDLTDYLMKILTERGYSFVTTAEREIVRDIKEKLCYVALDFENEMATAASSSSLEKSYELPDGQVITIGNERFRCPETLFQPSFIGMESAGIHETTYNSIMKCDIDIRKDLYANNVMSGGTTMYPGIADRMQKEITALAPSTMKIKIIAPPERKYSVWIGGSILASLSTFQQMWITKQEYDEAGPSIVHRKCF"
~~~
{: .output}

However, a major limitation of simple character vectors is that they do not check the validity of the sequences that they contain.
Practically, it is possible to store meaningless sequences of characters symbols in strings, causing programs to run into errors when they unexpectedly encounter invalid character symbols in a sequence.

Classes are a way to label objects as "DNA", "RNA", or "protein" sequence.
This label is an extremely powerful way to inform programs on what character symbols they can expect in the sequence, but also what operations can be applied to those sequences.
For instance, a function designed to translate nucleic acid sequences into the corresponding amino acid sequence should not be allowed to run on an amino acid sequence.

## The Biostrings package

The *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package implements classes to represent such sequences as S4 classes, e.g. `DNAString`, `AAString`.
Those S4 classes provide memory-efficient string containers, while other methods implemented in the package provide various string matching algorithms and other utilities for fast manipulation of large biological sequences or sets of sequences.

A short presentation of the basic classes defined in the *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package is available in one of the package vignettes.


~~~
vignette("Biostrings2Classes")
~~~
{: .language-r}

To get started, we load the package.


~~~
library(Biostrings)
~~~
{: .language-r}

With the package loaded and attached to the session, we have access to the package functions.
Those include functions that let us create new objects of the classes defined in the package; those functions are called _constructors_.
For instance, we can create an object that represents a DNA sequence, using the `DNAString()` constructor function.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}

Notably, DNA sequences may only contain the characters A, T, C, and G, to represent the four DNA nucleotide.
Notice that the constructor function does not let us create objects that contain invalid characters, that do not represent any of those four nucleotide.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}


~~~
DNAString("ATCGE")
~~~
{: .language-r}



~~~
Error in .Call2("new_XString_from_CHARACTER", class(x0), string, start, : key 69 (char 'E') not in lookup table
~~~
{: .error}

That said, the symbols that compose the alphabet DNA sequences are not limited to the characters A, T, C, and G.
The [IUPAC Extended Genetic Alphabet][iupac-alphabet] defines additional nucleotide code that represent combinations of nucleotides, in a way similar to regular expressions.
The `IUPAC_CODE_MAP` 


~~~
IUPAC_CODE_MAP
~~~
{: .language-r}



~~~
     A      C      G      T      M      R      W      S      Y      K      V      H      D      B      N 
   "A"    "C"    "G"    "T"   "AC"   "AG"   "AT"   "CG"   "CT"   "GT"  "ACG"  "ACT"  "AGT"  "CGT" "ACGT" 
~~~
{: .output}

Any of those nucleotide codes are allowed in the sequence of a `DNAString` object.


~~~
DNAString("ATCGM")
~~~
{: .language-r}



~~~
5-letter DNAString object
seq: ATCGM
~~~
{: .output}


## Importing biological strings from files

In practice, we rarely type the strings representing biological sequences ourselves.
Most of the time, we read those from files that we download from the web, or that we generate as outputs from other programs.
For instance, we load the set of human protein sequences obtained from the high quality manually annotated and non-redundant protein sequence database of the UniProt knowledge base, that we downloaded during the lesson setup.


~~~
human_proteins <- readAAStringSet(filepath = "data/uniprot-filtered-reviewed_human_96.fasta.gz")
human_proteins
~~~
{: .language-r}



~~~
AAStringSet object of length 20371:
        width seq                                                                                   names               
    [1]   395 MNGPVDGLCDHSLSEGVFMFTSESVGEGHPDKICDQISDAV...LRPGVIVRDLDLKKPIYQKTACYGHFGRSEFPWEVPRKLVF sp|Q00266|METK1_H...
    [2]   471 MENLKHIITLGQVIHKRCEEMKYCKKQCRRLGHRVLGLIKP...EPLGEDCPSELREIIDECRAHDPSVRPSVDEILKKLSTFSK sp|Q8NB16|MLKL_HU...
    [3]  1124 MGENEDEKQAQAGQVFENFVQASTCKGTLQAFNILTRHLDL...EQEAPRRDTPTESSCAVAAIGTLEGSPPVHFSLPVLHPLLG sp|O94851|MICA2_H...
    [4]  1067 MASPTSTNPAHAHFESFLQAQLCQDVLSSFQELCGALGLEP...RQAEDQVLRKLVDLVNQRDALIRFQEERRLSELALGTGAQG sp|Q8TDZ2|MICA1_H...
    [5]   270 MAASSSGEKEKERLGGGLGVAGGNSTRERLLSALEDLEVLS...NMLPPNHSSDFLLEPPGHNKENEDDVEIMSTDSSSSSSESD sp|Q9NPJ6|MED4_HU...
    ...   ... ...
[20367]   348 MPHIDNDVKLDFKDVLLRPKRSTLKSRSEVDLTRSFSFRNS...ILGGIRSTCTYVGAAKLKELSRRTTFIRVTQQVNPIFSEAC sp|Q9P2T1|GMPR2_H...
[20368]   553 MPLPWSLALPLLLSWVAGGFGNAASARHHGLLASARQPGVC...DATKSIIFEAERGKGKTGEIAVDGVLLVSGLCPDSLLSVDD sp|Q8IUX8|EGFL6_H...
[20369]   352 MASRKEGTGSTATSSSSTAGAAGKGKGKGGSGDSAVKQVQI...ARMDSLLIAGQINTYCQNIKEFTAQNLGKLFMAQALQEYNN sp|O15372|EIF3H_H...
[20370]   163 MSLLLLVVSALHILILILLFVATLDKSWWTLPGKESLNLWY...EEILEKHPRGGSFGYCFALAWVAFPLALVSGIIYIHLRKRE sp|P54852|EMP3_HU...
[20371]   254 MDNYADLSDTELTTLLRRYNIPHGPVVGSTRRLYEKKIFEY...GAGLGQDRQVPLWGQLLLFLVFVIVLFFIYHFMQAEEGNPF sp|P50402|EMD_HUM...
~~~
{: .output}


## Computing the frequency of symbols

The *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package provides several functions to process and manipulate classes of biological strings.
For instance, the `Biostrings::letterFrequency()` calculates the frequency of letters in a biological sequence, or the consensus matrix of a set of sequences (see the help page using `?Biostrings::letterFrequency`).

The `methods::showMethods()` function can be used to identify which classes are supported by the method.
Below, we see that the method does support the class `AAStringSet`.
In particular, the output indicates that S4 method dispatch will call the method implemented for the class `XStringSet` - a class from which `AAStringSet` inherits - which implicitly indicates that there is no method specifically implemented for the `AAStringSet`.


~~~
showMethods("letterFrequency")
~~~
{: .language-r}



~~~
Function: letterFrequency (package Biostrings)
x="MaskedXString"
x="XString"
x="XStringSet"
x="XStringViews"
~~~
{: .output}

We now know that we can use the `letterFrequency()` method on our object `human_proteins`, which is of class `AAStringSet`.

The output is a matrix with one row for each sequence, and one column for each symbol in the alphabet of amino acids, provided by the *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package in an object called `AA_ALPHABET`.


~~~
human_proteins.freq <- letterFrequency(human_proteins, letters = AA_ALPHABET)
head(human_proteins.freq)
~~~
{: .language-r}



~~~
       A  R  N  D  C  Q  E  G  H  I   L  K  M  F  P  S  T  W  Y  V U O B J Z X * - + .
[1,]  29 22  8 31 10 17 21 34 12 22  31 22 10 12 16 20 21  4 13 40 0 0 0 0 0 0 0 0 0 0
[2,]  22 35 13 20 10 28 47 22  8 33  50 43 12 16 19 32 21  4 11 25 0 0 0 0 0 0 0 0 0 0
[3,]  80 72 57 48 26 48 79 66 35 37 111 75 19 55 65 89 60 13 28 61 0 0 0 0 0 0 0 0 0 0
[4,] 100 66 31 42 19 67 87 79 27 19 133 47 17 35 70 71 54 17 21 65 0 0 0 0 0 0 0 0 0 0
[5,]  21 13 14 14  1 15 29 19  7 12  33 16 10  2 14 27  6  2  4 11 0 0 0 0 0 0 0 0 0 0
[6,]  24 21 29 27 13  6 28 20 10 33  38 28  6 19 12 47 34  3 13 31 0 0 0 0 0 0 0 0 0 0
~~~
{: .output}


~~~
dim(human_proteins.freq)
~~~
{: .language-r}



~~~
[1] 20371    30
~~~
{: .output}


[pkg-methods]: https://stat.ethz.ch/R-manual/R-devel/library/methods/html/00Index.html
[iupac-alphabet]: https://www.bioinformatics.org/sms/iupac.html
[glossary-s4-slot]: ../reference.html#s4-class-slot
[glossary-s4-class]: ../reference.html#s4-class
[glossary-s4-object]: ../reference.html#s4-object
[glossary-s4-dispatch]: ../reference.html#s4-method-dispatch
