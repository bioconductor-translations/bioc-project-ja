---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 06-biological-sequences.md in _episodes_rmd/
source: Rmd
title: "Working with biological sequences"
teaching: XX
exercises: XX
questions:
- "What is the recommended way to represent biological sequences in Bioconductor?"
- "What Bioconductor packages provides methods to efficiently process biological sequences?"
objectives:
- "Explain how biological sequences are represented in the Bioconductor project."
- "Identify Bioconductor packages and methods available to process biological sequences."
keypoints:
- "The `Biostrings` package defines classes to represent sequences of nucleotides and amino acids."
- "The `Biostrings` package also defines methods to efficiently process biological sequences."
- "The `BSgenome` package provides genome sequences for a range of model organisms immediately available as Bioconductor objects."
---





# Install packages

Before we can proceed into the following sections, we install some Bioconductor packages that we will need.


~~~
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Biostrings")
~~~
{: .language-r}


# The Biostrings package and classes

## Why do we need classes for biological sequences?

Biological sequences are arguably some of the simplest biological entities to represent computationally.
Examples include nucleic acid sequences (e.g., DNA, RNA) and protein sequences composed of amino acids.

That is because alphabets have been designed and agreed upon to represent individual monomers using character symbols.

For instance, using the alphabet for amino acids, the reference protein sequence for the [Actin, alpha skeletal muscle protein sequence](https://www.uniprot.org/uniprot/P68133#sequences) is represented as follows.


~~~
[1] "MCDEDETTALVCDNGSGLVKAGFAGDDAPRAVFPSIVGRPRHQGVMVGMGQKDSYVGDEAQSKRGILTLKYPIEHGIITNWDDMEKIWHHTFYNELRVAPEEHPTLLTEAPLNPKANREKMTQIMFETFNVPAMYVAIQAVLSLYASGRTTGIVLDSGDGVTHNVPIYEGYALPHAIMRLDLAGRDLTDYLMKILTERGYSFVTTAEREIVRDIKEKLCYVALDFENEMATAASSSSLEKSYELPDGQVITIGNERFRCPETLFQPSFIGMESAGIHETTYNSIMKCDIDIRKDLYANNVMSGGTTMYPGIADRMQKEITALAPSTMKIKIIAPPERKYSVWIGGSILASLSTFQQMWITKQEYDEAGPSIVHRKCF"
~~~
{: .output}

However, a major limitation of regular character vectors is that they do not check the validity of the sequences that they contain.
Practically, it is possible to store meaningless sequences of symbols in character strings.
In those cases, the burden of checking the validity of sequences falls on the programs that process them, or causing those programs to run into errors when they unexpectedly encounter invalid character symbols in a sequence.

Instead, [S4 classes][glossary-s4-class] -- demonstrated in the earlier episode [The S4 class system][crossref-s4] -- provide a way to label objects as distinct "DNA", "RNA", or "protein" varieties of biological sequences.
This label is an extremely powerful way to inform programs on the set of character symbols they can expect in the sequence, but also the range of computational operations that can be applied to those sequences.
For instance, a function designed to translate nucleic acid sequences into the corresponding amino acid sequence should only be allowed to run on sequences that represent nucleic acids.

## The Biostrings package

The *[Biostrings](https://bioconductor.org/packages/3.14/Biostrings)* package implements S4 classes to represent biological sequences as S4 objects, e.g. `DNAString` for sequences of nucleotides in deoxyribonucleic acid polymers, `AAString` for sequences of amino acids in protein polymers.
Those S4 classes provide memory-efficient containers for character strings, while other methods implemented in the package provide various string matching algorithms and other utilities for fast manipulation and processing of large biological sequences or sets of sequences.

A short presentation of the basic classes defined in the *[Biostrings](https://bioconductor.org/packages/3.14/Biostrings)* package is available in one of the package vignettes.


~~~
vignette("Biostrings2Classes")
~~~
{: .language-r}

More detailed information is provided in the other package vignettes.


~~~
browseVignettes("Biostrings")
~~~
{: .language-r}

To get started, we load the package.


~~~
library(Biostrings)
~~~
{: .language-r}

With the package loaded and attached to the session, we have access to the package functions.
Those include functions that let us create new objects of the classes defined in the package.
For instance, we can create an object that represents a DNA sequence, using the `DNAString()` constructor function.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}

Notably, DNA sequences may only contain the characters `A`, `T`, `C`, and `G`, to represent the four DNA nucleotide.
Notice that the constructor function does not let us create objects that contain invalid characters, that do not represent any of those four nucleotide.


~~~
DNAString("ATCGZ")
~~~
{: .language-r}



~~~
Error in .Call2("new_XString_from_CHARACTER", class(x0), string, start, : key 90 (char 'Z') not in lookup table
~~~
{: .error}

That said, the symbols that compose the alphabet DNA sequences are not limited to characters representing the individual nucleotides, i.e. `A`, `T`, `C`, and `G`.
The [IUPAC Extended Genetic Alphabet][iupac-alphabet] defines additional nucleotide codes that represent sets of nucleotides, in a way similar to regular expressions.
The `IUPAC_CODE_MAP` named character vector contains the mapping from the IUPAC nucleotide ambiguity codes to their meaning.


~~~
IUPAC_CODE_MAP
~~~
{: .language-r}



~~~
     A      C      G      T      M      R      W      S      Y      K      V      H      D      B      N 
   "A"    "C"    "G"    "T"   "AC"   "AG"   "AT"   "CG"   "CT"   "GT"  "ACG"  "ACT"  "AGT"  "CGT" "ACGT" 
~~~
{: .output}

Any of those nucleotide codes are allowed in the sequence of a `DNAString` object.
For instance, the symbol `M` represents either of the two nucleotides `A` or `C` at a given position in a nucleic acid sequence.


~~~
DNAString("ATCGM")
~~~
{: .language-r}



~~~
5-letter DNAString object
seq: ATCGM
~~~
{: .output}

Pattern matching methods implemented in the *[Biostrings](https://bioconductor.org/packages/3.14/Biostrings)* package recognize the meaning of ambiguity codes for each class of biological sequence, allowing them to efficiently match motifs queried by users without the need to design elaborate regular expressions.
For instance, the method `matchPattern()` takes a `pattern` and a `subject` sequence, and returns a set of `Views` that report and display any match of the pattern in the sequences.

The default option `fixed = TRUE` instructs the method to ignore ambiguity codes -- and thus, match the string `GA` exactly -- which in this case does not report any exact match.


~~~
dna1 <- DNAString("ATCGMTTTGA")
matchPattern("GA", dna1, fixed = TRUE)
~~~
{: .language-r}



~~~
Views on a 10-letter DNAString subject
subject: ATCGMTTTGA
views:
      start end width
  [1]     9  10     2 [GA]
~~~
{: .output}

Instead, to indicate that the pattern includes some ambiguity code, the argument `fixed` must be set to `FALSE`.


~~~
matchPattern("GA", dna1, fixed = FALSE)
~~~
{: .language-r}



~~~
Views on a 10-letter DNAString subject
subject: ATCGMTTTGA
views:
      start end width
  [1]     4   5     2 [GM]
  [2]     9  10     2 [GA]
~~~
{: .output}

In this particular example, two views describes matches of the pattern in the subject sequence.
Specifically, the pattern `GA` first matched the sequence `GM` spanning positions 4 to 5 in the subject sequence, and then also matched exactly the sequence `GA` from positions 9 to 10.

Similarly to the method `matchPattern()`, the method `countPattern()` can be applied to simply count the number of matches of the `pattern` in the `subject` sequence.
And again, the option `fixed` controls whether to respect ambiguity codes, or match them exactly.

> ## Challenge
> 
> How many hits does the following code return? Why?
> 
> ```
> dna2 <- DNAString("TGATTGCTTGGTT")
> countPattern("GM", dna1, fixed = FALSE)
> ```
> 
> > ## Solution
> > 
> > The method `countPattern()` reports 2 hits, because the option `fixed = FALSE` allow the pattern `GM` to match `GA` and `GC` sequences, due to the use of the ambiguity code `M` in the `pattern`.
> {: .solution}
{: .challenge}

## Importing biological strings from files

In practice, users rarely type the strings representing biological sequences themselves.
Most of the time, biological strings are imported from files, either downloaded from public repositories or generated locally using bioinformatics programs.

For instance, we load set of adapter sequences for the [TruSeqâ„¢ DNA PCR-Free whole-genome sequencing library preparation][external-truseq] kit, from a file that we downloaded the file during the lesson setup.
Since adapter sequences are nucleic acid sequences, we use the function `readDNAStringSet()`.


~~~
truseq_adapters <- readDNAStringSet(filepath = "data/TruSeq3-PE-2.fa")
truseq_adapters
~~~
{: .language-r}



~~~
DNAStringSet object of length 6:
    width seq                                                                                       names               
[1]    34 TACACTCTTTCCCTACACGACGCTCTTCCGATCT                                                        PrefixPE/1
[2]    34 GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT                                                        PrefixPE/2
[3]    34 TACACTCTTTCCCTACACGACGCTCTTCCGATCT                                                        PE1
[4]    34 AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTA                                                        PE1_rc
[5]    34 GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT                                                        PE2
[6]    34 AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC                                                        PE2_rc
~~~
{: .output}

> ## Note
> 
> The help page of the function `readDNAStringSet()` -- accessible using `?readDNAStringSet` -- documents related functions designed to import other types of biological sequences, e.g `readRNAStringSet()`, `readAAStringSet()`.
{: .callout}

## Computing the frequency of symbols

The *[Biostrings](https://bioconductor.org/packages/3.14/Biostrings)* package provides several functions to process and manipulate classes of biological strings.
For example, we have come across `matchPattern()` and `countPattern()` earlier in this episode.

Another example of method that can be applied to biological strings is to compute the frequency of letters in a biological sequence, using  the method `letterFrequency()`.


~~~
letterFrequency(truseq_adapters, letters = DNA_ALPHABET)
~~~
{: .language-r}



~~~
      A  C  G  T M R W S Y K V H D B N - + .
[1,]  6 14  3 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[2,]  5  8 10 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[3,]  6 14  3 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[4,] 11  3 14  6 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[5,]  5  8 10 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[6,] 11 10  8  5 0 0 0 0 0 0 0 0 0 0 0 0 0 0
~~~
{: .output}

The output is a matrix with one row for each sequence, and one column for each symbol in the alphabet of deoxyribonucleic acids, provided by the *[Biostrings](https://bioconductor.org/packages/3.14/Biostrings)* package in an object called `DNA_ALPHABET`.

[pkg-methods]: https://stat.ethz.ch/R-manual/R-devel/library/methods/html/00Index.html
[iupac-alphabet]: https://www.bioinformatics.org/sms/iupac.html
[crossref-s4]: ../05-s4/index.html
[external-truseq]: https://emea.illumina.com/products/by-type/sequencing-kits/library-prep-kits.html
[glossary-s4-slot]: ../reference.html#s4-class-slot
[glossary-s4-class]: ../reference.html#s4-class
[glossary-s4-object]: ../reference.html#s4-object
[glossary-s4-dispatch]: ../reference.html#s4-method-dispatch
